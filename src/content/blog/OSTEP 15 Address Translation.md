---
title: OSTEP 15 Address Translation
date: 2023-07-17
tags:
  - cs
  - os
---

CPU 가상화 부분에서 **제한적 직접 실행 (LDE)** 기법에 대해 배웠다. [[OSTEP 06 Direct Execution]]
메모리 가상화에서도 비슷한 전략을 추구한다. 가상화를 제공하는 동시에 효율성과 제어 모두를 추구한다.

**효율성**을 높이기 위해 하드웨어 자원을 활용한다. 몇 개의 레지스터 활용부터 TLB, 페이지 테이블 등 점점 복잡한 하드웨어를 사용한다.
**제어**는 프로그램이 자기 자신의 메모리 이외에는 접근하지 못하도록 운영체제가 보장한다는 것.
유연성 측면에서, 프로그래머가 원하는 대로 주소 공간을 사용하고, 프로그래밍하기 쉬운 시스템을 만들기 원헌다.

***핵심 질문: 어떻게 효율적이고 유연하게 메모리를 가상화 할 수 있을까?***

우리가 다룰 기법은 **(하드웨어 기반) 주소 변환**이다. 이 기술은 제한적 직접 실행 방식에 부가적으로 사용되는 기능이라고 생각할 수 있다. 주소 변환을 통해 하드웨어는 명령어 반입, 탑재, 저장 등의 **가상** 주소를 정보가 실제 존재하는 **물리** 주소로 변환한다.

하드웨어가 변환을 가속화하는데 도움을 주지만 그것만으로는 모자라다. 정확한 변환이 일어날 수 있도록 운영체제가 관여해야 한다.

운영체제는 **메모리의 빈 공간과 사용중인 공간을 항상 알고 있어야 하고, 메모리 사용을 제어하고 관리한다.**

이 모든 작업의 목표는 바로 ***프로그램이 자신의 전용 메모리를 소유하고 있고, 그 안에 자신의 코드와 데이터가 있다는 환상***을 만드는 것이다.

## 1. 가정

1. 주소 공간은 물리 메모리에 연속적으로 배치되어야 한다.
2. 주소 공간은 물리 메모리 크기보다 작다.
3. 각 주소 공간의 크기는 같다.

## 2. 사례

```c
void func() {
	int x = 3000;
	x = x + 3; // 우리가 관심있는 코드
}
```

```asm
128: movl 0x0(\%ebx), \%eax;	# 0+ebx를 eax에 저장 
132: addl \$0x03, \%eax;		# eax레지스터에 3을 더한다   
135: movl \%eax, 0x0(\%ebx);	# eax를 메모리에 다시 저장
```

`x`의 주소가 레지스터 `ebx`에 저장되어 있다고 가정하고, 이 주소에 저장되어 있는 값을 범용 레지스터 `eax`에 넣는다. 다음 명령은 `eax`에 3을 더하고,  마지막 명령은 `eax`의 값을 같은 위치의 메모리에 저장한다.

프로그램 코드는 주소 128에 위치하고 변수 `x`의 값은 주소 15KB (아래 쪽 스택)에 위치한다.
이 프로그램이 실행되면 다음과 같은 메모리 접근이 일어난다.

- 주소 128의 명령어를 반입
- 이 명령어 실행 (주소 15 KB에서 탑재)
- 주소 132의 명령어를 반입
- 이 명령어 실행 (메모리 참조 없음)
- 주소 135의 명령어를 반입
- 이 명령어 실행 (15 KB에 저장)

![[OSTEP 15 Address Translation-1689616534903.jpeg]]

이렇게 프로세스 관점에서 메모리 주소가 0부터 시작하도록 가상 환경을 제공해야 한다.

![[OSTEP 15 Address Translation-1689616860906.jpeg]]

실제로는 0부터 시작하지 않더라도 프로그램이 0부터 시작하는 것 처럼 작동해야 한다.

## 3. 동적 (하드웨어-기반) 재배치

### Base And Bound (dynamic relocation)

각 CPU마다 2개의 하드웨어 레지스터가 필요하다. 
하나는 **베이스 레지스터**로, **프로세스의 주소 공간이 시작하는 물리 메모리 주소**를 저장한다. 
다른 하나는 **바운드 레지스터**로, **프로세스의 주소 공간 크기**를 저장한다.

```c
physical address = virtual address + base
```

```asm
128: movl 0x0(%EBX) , % eax
```

하드웨어가 이 명령어를 반입할 때, PC값(128)을 베이스 레지스터의 값(32KB = 32768)에 더해서 물리 주소(32896)를 얻는다.

이 주소의 재배치는 실행 시에 일어나고, 실행 후에도 주소 공간을 이동할 수 있기 때문에 **동적 재배치 (dynamic relocation)** 라고도 불린다.

바운드 레지스터는 보호를 지원하기 위해 존재한다. 가상 주소가 바운드 안에 있는지 확인하는 용도. 바운드보다 큰 가상 주소를 참조하면 CPU는 예외를 발생시키고 프로세스가 종료된다.
바운드 레지스터 구현 방법은 두 가지가 있다.
1. 주소 공간의 크기 저장
2. 주소 공간의 마지막 물리 주소를 저장

이렇게 주소 변환에 도움을 주는 프로세서의 일부를 메모리 관리 장치 (MMU) 라고 부른다.

### 예제
주소 공간의 크기가 4KB(4096)인 프로세스가 물리 주소 16KB(16384)에 탑재되어 있다고 가정하자.

![[OSTEP 15 Address Translation-1689617753303.jpeg]]

가상 주소가 너무 크면(바운드를 벗어나면) 오류가 발생한다.

## 4. 하드웨어 지원 요약

![[OSTEP 15 Address Translation-1689673685369.jpeg]]

## 5. 운영체제 이슈

베이스와 바운드 방식의 가상 메모리 구현을 위해 운영체제가 반드시 개입되어야 하는 시점이 4개 존재한다.

1. 프로세스가 생성될 때 운영체제는 주소 공간이 저장될 메모리 공간을 찾아 조치를 취해야 한다.
2. 프로세스가 종료할 때(정상적 종료 및 잘못된 행동으로 인한 강제 종료) 사용하던 메모리를 회수하여 다른 프로세스나 운영체제가 사용할 수 있게 해야 한다.
3. 운영체제는 문맥 교환이 일어날 때, 베이스와 바운드 쌍을 저장하고 복원해야 한다. -> PCB에 있음
4. 예외가 발생할 때 호출될 함수를 제공해야 한다. -> 부팅할 때 설치

![[OSTEP 15 Address Translation-1689674031826.jpeg]]

![[OSTEP 15 Address Translation-1689674090849.jpeg]]
