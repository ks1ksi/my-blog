---
title: OSTEP 38 Redundant Disk Arrays (RAID)
date: 2023-10-30
tags:
  - cs
  - os
---

RAID는 여러 개의 디스크를 조화롭게 사용하여 고속이면서 대용량의 신뢰할 수 있는 디스크 시스템을 만드는 기술이다. 하나의 디스크처럼 보이지만 사실은 여러 개의 디스크와 메모리, 시스템을 관리하기 위한 하나 또는 그 이상의 프로세서로 이루어진 복잡한 기계이다.

RAID는 단일 디스크에 비해 여러 장점들을 제공한다. 첫 번째는 **성능**이다. 디스크 여러 개를 병렬로 사용하면 I/O 시간이 크게 개선된다. 또 다른 장점은 **용량**이다. 여러 디스크를 사용해서 용량을 늘릴 수 있다. 마지막 장점은 **신뢰성**이다. 데이터 중복 기술을 사용해서 RAID는 디스크 고장이 전혀 없던 것 처럼 데이터를 잃지 않을 수 있다. 

호스트 시스템은 RAID를 그저 거대한 디스크로 인식한다. 운영체제와 클라이언트 응용 프로그램은 코드 한 줄 바꾸지 않고 RAID를 사용할 수 있다. 이 투명성은 RAID가 확산되는데 기여하였다.

## 1. 인터페이스와 RAID의 내부

파일 시스템이 RAID에 *논리적* I/O를 요청하면 RAID 내부에서 어떤 디스크를 접근해야 요청을 완료할 수 있는지 계산한 후, 하나 혹은 그 이상의 *물리적* I/O를 발생시킨다. 간단한 예로 서로 다른 디스크 2개에 복사본을 유지하는 *미러링 기반* RAID를 생각해 보자. 이 시스템에서 블럭에 쓰기를 하는 경우, 하나의 논리적 I/O에 대해 두 개의 물리적 I/O가 발생한다.

RAID 시스템은 보통 별도의 하드웨어 박스 형태로 되어 있고, 호스트와 SCSI / SATA와 같은 표준 인터페이스로 연결된다. RAID 시스템의 내부에는 작업을 지시하는 펌웨어를 위한 마이크로 컨트롤러, 블럭을 읽고 쓸 때 버퍼로 쓰는 휘발성 메모리 DRAM, 안전한 쓰기를 위한 비휘발성 메모리, 패리티 계산을 위한 전용 회로 등이 존재한다. 사실상 하나의 특수한 컴퓨터 시스템이다. 차이점은 응용 프로그램을 실행하는 대신 RAID를 동작시키기 위해 설계된 전용 소프트웨어를 실행한다는 점이다.

## 2. 결함 모델

RAID는 특정 종류의 결함을 파악하고 이를 복구하도록 설계되어 있다. 

가장 간단한 모델은 고장 시 멈춤 (fail-stop) 모델이다. 

이 모델에서 디스크는 "정상 작동" 이거나 "멈춤" 둘중 하나의 상태로 존재한다고 가정한다. 동작 중인 디스크에는 모든 블럭을 읽거나 쓸 수 있다. 멈춤 상태의 디스크는 완전히 사용 불가능하다고 간주한다.

고장 시 멈춤 모델의 치명적인 단점은 **결함이 발견되는 경우에 대한 가정**이다. 결함이 발생하면 바로 알 수 있을까? 쉽지 않은 일이다. 

## 3. RAID의 평가 방법

3개의 축을 중심으로 RAID 설계를 평가할 것이다. 

첫 번째 평가의 축은 **용량**이다. B개의 블럭을 가지는 N개의 디스크가 주어졌을 때 RAID의 클라이언트가 사용할 수 있는 유효 용량은 얼마일까? 중복 저장이 없는 경우라면 답은 $N \times B$ 가 될 것이다. 각 블럭에 대해 두 개의 복사본을 가지는 경우 (미러링) 답은 $(N \times B) \div 2$가 될 것이다. 패리티 기반 기법같이 다른 기법들은 그 사이의 값을 가지게 된다.

두 번째 평가의 축은 **신뢰성**이다. 평가 대상의 설계 방법은 몇 개의 디스크 결함을 감내할 수 있는가? 우리의 결함 모델에 따라 하나의 디스크만 고장날 수 있다고 가정하고, 좀 더 복잡한 결함 모드를 처리하는 방법은 추후에 알아보도록 하자. 

마지막 세 번째 평가의 축은 **성능**이다. 디스크가 처리할 워크로드에 따라 성능 지표가 달라진다. 성능을 평가하기 이전에 고려해야 할 일반적인 워크로드를 제시할 것이다.

이제 세 개의 중요한 RAID 설게를 살펴보며 평가해보자.
RAID 레벨 0(스트라이핑), RAID 레벨 1(미러링) 그리고 RAID 레벨 4/5(패리티에 기반을 둔 중복 저장)를 다루도록 하겠다.

## 4. RAID 레벨 0: 스트라이핑

가장 간단한 스트라이핑은 블럭들을 여러 디스크에 걸쳐서 줄을 긋는 것 처럼 저장한다. 

![[OSTEP 38 Redundant Disk Arrays (RAID)-1698697470879.jpeg]]

이 접근법은 배열의 연속적인 청크에 대해 요청을 받았을 때 **병렬성**을 가장 잘 활용할 수 있도록 설계되었다 . 같은 행에 있는 블럭들을 **스트라이프(stripe)** 라고 부른다. 

이 예에서는 단순하게 하나의 블럭 (4KB)만이 다음 디스크로 넘어가기 전에 현재 디스크에 배치되도록 했다. 하지만 이렇게 배치할 수도 있다.

![[OSTEP 38 Redundant Disk Arrays (RAID)-1698674794744.jpeg]]

이 예제에서는 각 디스크바다 두 개의 4KB 블럭을 배치한 후에 다음 디스크로 넘어갔다. 그러므로 이 RAID 배열의 **청크 크기는 8KB**이고, **스트라이프는 4개의 청크 또는 32KB** 크기의 데이터를 저장한다. 

### 청크 크기

청크 크기는 RAID의 성능에 큰 영향을 준다. 작은 청크 크기는 많은 파일들이 여러 디스크에 걸쳐서 스트라이프 된다는 뜻이고 결국 **하나의 파일을 읽고 쓰는데 병렬성이 증가**하게 된다. 

하지만 블럭의 위치를 여러 디스크에서 찾아야 하므로 **위치 찾기** 시간이 늘어난다. 요청 처리 시간은 여러 디스크에 걸친 요청들 중 가장 오래걸린 찾기 시간에 의해 결정되기 때문이다. 

반면 큰 청크 크기의 경우에는 파일 내의 병렬성은 줄어들고 위치 찾기 시간은 줄어든다. 파일이 작아서 단일 청크에 저장이 된다면, 한 디스크에서 그 위치를 찾는 시간만큼 걸리기 때문이다. 

최적의 청크 크기를 정하는 것은 워크로드에 따라 다르다. 이 글에서는 청크 크기를 한 블럭의 크기 (4KB)로 가정하지만 대부분의 RAID에선 64KB처럼 큰 청크를 사용한다.

### 평가
- 용량: 중복 저장이 없으므로 $N \times B$ 
- 신뢰성: 중복 저장이 없기 때문에 하나의 디스크라도 고장나면 데이터 손실 위험이 존재
- 성능: 스트라이핑을 통해 여러 디스크에 동시에 데이터를 저장하므로 높은 성능 제공

## 5. RAID 레벨 1: 미러링

미러링을 사용하는 시스템에서는 각 블럭에 대해 하나 이상의 사본을 둔다. 각 사본은 서로 다른 디스크에 저장되어야 한다. 이를 통해 디스크 고장에 대처할 수 있기 때문이다.

![[OSTEP 38 Redundant Disk Arrays (RAID)-1698675720052.jpeg]]

### 평가
- 용량: 모든 데이터가 미러링되기 때문에 $(N \times B) \div 2$ . 비용이 좀 더 들게 된다
- 신뢰성: 미러링 기법으로 인해 하나의 디스크가 고장나도 데이터가 손실되지 않는다. 최소 1개의 디스크 결함 감내 가능. 이론상 $N \div 2$개까지 감내 가능.
- 성능: 읽기 성능은 양쪽 디스크에서 동시에 데이터를 읽을 수 있기 때문에 높은 편이지만, 쓰기 성능은 데이터를 두 디스크에 동시에 써야 하기 때문에 RAID 0에 비해 감소.

## 6. RAID 레벨 4: 패리티를 이용한 공간 절약

패리티 기반의 접근 방법은 저장 공간을 더 적게 사용하기 위해 나타났다. 미러링 기반 시스템의 공간 낭비를 해결해보자. 대신 성능은 좋지 못하다.

![[OSTEP 38 Redundant Disk Arrays (RAID)-1698678115713.jpeg]]

각 데이터 스트라이프마다 해당 스트라이프에 대한 중복 정보를 담고 있는 **패리티 블럭** 하나를 추가한다. 패리티를 계산하기 위해 스트라이프에 속해 있는 블럭 중 하나의 블럭이 고장나더라도 견딜 수 있게 하는 함수가 필요하다. **XOR**을 이용해보자. 

![[OSTEP 38 Redundant Disk Arrays (RAID)-1698678418793.jpeg]]

1이 짝수 개일 때는 0을 반환하고 홀수 개일 때는 1을 반환한다.

C2열이 깨졌다고 해보자. 그러면 그 열에 있었던 값들을 알아보기 위해 그 행의 모든 값을 읽은 후 올바른 값을 **다시** 계산하면 된다. 첫 번째 행에서 C0, C1, C3의 값을 XOR 하면 1이 되고, XOR 값은 0이 되어야 하기 때문에 C2 값은 1이 되어야 한다는 것을 알 수 있다. 

블럭 단위로 XOR은 어떻게 해야 할까?

![[OSTEP 38 Redundant Disk Arrays (RAID)-1698678929072.jpeg]]

블럭의 각 비트들에 대해 XOR을 수행하면 된다. 

### 평가
- 용량: 패리티 정보의 저장을 위해 각 디스크 그룹에 속한 디스크 하나를 사용하기 때문에 $(N-1) \times B$ 의 저장 공간을 제공한다.
- 신뢰성: 오직 하나의 디스크 고장만을 감내할 수 있다. 두 개 이상의 디스크가 고장나면 패리티 계산이 불가능해 데이터를 복원할 수 없다. 
- 성능: 패리티 디스크를 제외한 모든 디스크를 활용할 수 있기 때문에 읽기 성능은 높다. 하지만 쓰기의 경우는 생각해볼 필요가 있다. 순차 쓰기의 경우는 *스트라이프 전부 쓰기*로 최적화할 수 있다. 한 행에 모두 쓰면서 패리티까지 계산하고 쓸 수 있다. 랜덤 쓰기의 경우는 이전 블럭의 값이 새로 쓰는 값과 동일한지 보고, 패리티 비트를 반전시키는 방식을 사용한다.

### 문제점
![[OSTEP 38 Redundant Disk Arrays (RAID)-1698689027071.jpeg]]

블럭 4번과 13번을 갱신하는 쓰기는 병렬으로 처리될 수 있다. 하지만 패리티 1번과 3번을 읽어야 한다. 이 부분은 병렬으로 처리될 수 없다. 이같은 경우를 패리티 기반 RAID의 **small-write** 문제라고 한다.

## 7. RAID 레벨 5: 순환 패리티

small-write 문제를 해결하기 위해 패리티 블럭을 순환시킨다.

![[OSTEP 38 Redundant Disk Arrays (RAID)-1698689123661.jpeg]]

### 평가
모두 RAID 4와 동일하지만 모든 디스크를 활용할 수 있기 때문에 랜덤 읽기 성능이 약간 더 좋고, 랜덤 쓰기 성능이 RAID 4에 비해 눈에 띄게 좋아진다.

## 8. 정리

![[OSTEP 38 Redundant Disk Arrays (RAID)-1698689190850.jpeg]]
