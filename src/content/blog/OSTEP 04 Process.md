---
title: OSTEP 04 Process
date: 2023-07-03
tags:
  - cs
  - os
---

## 1. 프로세스의 개념

**프로세스는 실행 중인 프로그램**을 의미한다.

그리고 **프로그램은 디스크에 존재하는 명령어와 정적 데이터의 묶음**이다. 이것을 우리가 사용 가능하도록 실행하는 것이 운영체제의 목표이다.
프로세스의 구성 요소를 이해하기 위해서는 하드웨어 상태를 이해해야 한다. 프로그램이 실행되는 동안 하드웨어 상태를 읽거나 갱신할 수 있기 때문이다.
그중 가장 중요한 하드웨어 구성 요소는 **메모리**이다. 명령어와 프로그램이 읽고 쓰는 데이터는 모두 메모리에 저장된다.
**레지스터**도 중요한 구성 요소이다. **프로그램 카운터**는 프로그램의 어떤 명령어가 실행 중인지 알려준다. **스택 포인터와 프레임 포인터**는 함수의 변수와 리턴 주소를 저장하는 스택을 관리할 때 사용하는 레지스터이다.
또 프로그램은 **영구 저장장치**에 접근하기도 한다. 이 IO 정보는 프로세스가 현재 열어 놓은 파일 목록을 가지고 있다.

## 2. 프로세스 API

다음 챕터에서 자세히 다룰 예정이기 때문에 어떤 종류가 있는지만 확인.

- Create → 프로세스를 새로 생성한다
- Destroy → 프로세스를 강제로 종료한다
- Wait → 종료 전 대기
- Miscellaneous Control → 대기, 종료 외에 일시정지 및 재개 등
- Status → 얼마나 실행됐는지, 어떤 상태인지

## 3. 프로세스 생성

![[OSTEP 04 Process-1687712572337.jpeg]]

1. 프로그램 코드와 정적 데이터를 메모리, 프로세스의 주소 공간에 로드.
    1. 운영체제는 디스크의 해당 바이트를 읽어서 메모리의 어딘가에 올려야 한다.
    2. 필요한 부분만 메모리에 탑재 → 페이징, 스와핑 이해 필요. 예전에는 그냥 다 때려박음.
2. 일정량의 메모리가 프로그램의 실행시간 스택 (런타임 스택) 용도로 할당되어야 함.
3. 힙을 위한 메모리 영역도 할당되어야 함. (`malloc`, `free`)
4. 입출력과 관계된 초기화 작업 수행 (STDIN, STDOUT, STDERR 3개의 파일 디스크립터) → 3번째 부분인 영속성에서 다룸
5. 실행준비 완료. 프로그램의 시작 지점인 main()에서부터 프로그램 실행. 운영체제는 CPU를 새로 생성된 프로세스에게 할당. 프로그램 실행 시작.

## 4. 프로세스 상태

프로세스는 3가지 상태를 가진다.

![[OSTEP 04 Process-1687712593825.jpeg]]

1. 실행(Running): 프로세스는 명령어를 실행하고 있다.
2. 준비(Ready): 실행할 준비가 되어 있지만 운영체제가 다른 프로세스를 실행하고 있는 등의 이유로 기다리는 중
3. 대기(Blocked): 프로세스가 다른 사건을 기다리는 동안 프로세스의 수행을 중단시키는 연산. ex) 디스크에 대한 입출력 요청 → 순차적으로 실행해야 하기 때문에 다 완료될때까지 해당 프로세스는 멈춰있음(blocked).

운영체제는 어떤 프로세스를 실행할 지 스케쥴러를 통해 결정을 내린다.

## 5. 자료구조

운영체제는 다른 프로그램들처럼 정보를 유지하기 위한 자료 구조를 가지고 있다.
![[OSTEP 04 Process-1687712609999.jpeg]]

프로세스 상태를 파악하기 위한 프로세스 리스트 등.

운영체제는 이렇게 레지스터 및 프로세스의 상태를 저장하고, 이를 통해 프로세스 실행을 재개한다 (context switch)

참고: [[OSTEP 교재]]
