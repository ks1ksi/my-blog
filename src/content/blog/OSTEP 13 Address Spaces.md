---
title: OSTEP 13 Address Spaces
date: 2023-07-04
tags:
  - cs
  - os
---

## 1. 초기 시스템

운영체제는 메모리에 상주하는 루틴(라이브러리)의 집합이었다. 물리 메모리에 하나의 실행 중인 프로그램이 존재하였고, 운영체제가 쓰고 남은 메모리를 사용하였다. 가상화? 그런건 없었다.

![[OSTEP 13 Address Spaces-1688413695513.jpeg]]

## 2. 멀티프로그래밍과 시분할

멀티프로그래밍 시대가 왔다. 여러 프로세스가 실행 준비 상태에 있고, 운영체제가 이들을 전환하면서 실행하였다. 한 프로세스가 입출력을 하면, CPU는 다른 프로세스로 전환하였다.

이렇게 여러 프로세스간 전환을 통해 CPU의 이용률이 올라갔다. 사람들은 컴퓨터를 더 많이 사용하길 원했고, **시분할 (time sharing)** 방식을 사용했다. 일괄처리방식 (batch) 컴퓨팅의 한계를 느꼈기 때문이다.

시분할을 구현하는 한 가지 방법은 하나의 프로세스를 짧은 시간 동안 실행시키는 것이었다. 그런 후 프로세스를 중단하고, 중단 시점의 모든 상태를 디스크에 저장하고 다른 프로세스의 상태를 탑재하여 실행시키는 방식이었다.
하지만 이 방법에는 문제가 있었다. 메모리 크기가 커질수록 성능이 느려지는 문제가 발생했다.

다음 사진처럼 프로세스를 전환할 때, 프로세스를 메모리에 그대로 유지하면서, 시분할 방식으로 작동하도록 해야 한다. 

![[OSTEP 13 Address Spaces-1688414404626.jpeg]]

여러 프로세스들이 메모리의 일정 부분을 함께 사용한다. 함께 사용하려면, *한 프로세스가 다른 프로세스의 메모리를 읽거나 쓰지 못하도록 **보호(protection)** 해야 한다.*

## 3. 주소 공간

이러한 위험에 대비하여 운영체제는 사용하기 쉬운(추상화된) 메모리 개념인 **주소 공간(address space)** 를 만들었다. 프로세스는 자신의 주소 공간에만 접근한다.
주소 공간은 실행 프로그램의 모든 메모리 상태를 가지고 있다. 

![[OSTEP 13 Address Spaces-1688414817225.jpeg]]

그림에는 0KB부터 16KB라고 써있지만 실제로 물리 주소 0 ~ 16 사이에 존재하는 것은 아니다. A, B, C가 함께 메모리에 올라가 있는 그림처럼, 실제 물리 주소는 다를 수 있다. 

> **가상화**: 물리 메모리를 공유하는 다수의 프로세스에게 프로세스 전용의 커다란 주소 공간이라는 개념을 제공하는 것

그러면 메모리를 어떻게 가상화 하는 것일까?

## 4. 목표

가상 메모리 시스템 (VM) 의 주요 목표에 대해 살펴보자.

1. 투명성(transparency): 실행 중인 프로그램이 가상 메모리의 존재를 인지하지 못하도록 가상 메모리 시스템을 구현해야 한다. 물리 메모리를 소유한 것처럼 행동해야 한다.
2. 효율성(eiciency): 가상화를 지원하기 위해 너무 느리게 실행되거나 너무 많은 메모리를 소모해서는 안된다. TLB 등의 도움을 받을 수 있다.
3. 보호(protection): 프로세스를 다른 프로세스로부터 보호해야 한다. 운영체제 자신도 프로세스로부터 보호해야 한다. **절대 다른 프로세스나 운영체제의 메모리 내용에 접근하거나 영향을 줄 수 있어서는 안 된다.** 프로세스들을 서로 고립시켜야 한다.
